`define NOP 32'b0000_0000_0000_0000_0000_0000_0001_0011

module pre_if(
    input wire clock, 
    input wire reset,

    input wire stall,
    input wire bubble,
    output reg error,

    input wire [31:0] next_instr_ptr,
    output reg [31:0] instr_ptr
);
    parameter INSTR_BASE_ADDR = 32'h8000_0000;
    always_ff @(posedge clock or posedge reset) begin
        if(reset) begin
            instr_ptr <= INSTR_BASE_ADDR;
            error <= 1'b0;
        end else begin
            error <= stall && bubble;
            if(!stall) begin
                instr_ptr <= next_instr_ptr;
            end
        end
    end
endmodule

module if_id(
    input wire clock,
    input wire reset,

    input wire stall,
    input wire bubble,
    output reg error,

    input wire [31:0] if_ip,
    output reg [31:0] id_ip,

    input wire        if_jump_pred,
    output reg        id_jump_pred,

    input wire [31:0] if_instr,
    output reg [31:0] id_instr,

    // these signals are generated by cu_orchestra module.
    input wire [31:0] bubble_ip,

    input wire if_page_fault,
    output reg id_instr_page_fault,

    input wire if_addr_misaligned,
    output reg id_instr_addr_misaligned,

    input wire if_no_exec_access,
    output reg id_instr_no_exec_access
);
    parameter NOP = 32'b0000_0000_0000_0000_0000_0000_0001_0011;
    parameter INSTR_BASE_ADDR = 32'h8000_0000;
    always_ff @(posedge clock or posedge reset) begin
        if(reset) begin
            id_ip    <= INSTR_BASE_ADDR;
            id_jump_pred <= 1'b0;
            id_instr <= NOP;
            error    <=  1'b0;
            id_instr_page_fault <= 1'b0;
            id_instr_addr_misaligned <= 1'b0;
            id_instr_no_exec_access <= 1'b0;
        end else begin
            // error <= stall && bubble;
            if(bubble) begin
                id_ip        <= bubble_ip;
                id_jump_pred <= 1'b0;
                id_instr     <= NOP;
                id_instr_page_fault <= if_page_fault;
                id_instr_addr_misaligned <= if_addr_misaligned;
                id_instr_no_exec_access <= if_no_exec_access;
                
            end else if(!stall) begin
                id_ip        <= if_ip;
                id_jump_pred <= if_jump_pred;
                id_instr     <= if_instr;
                id_instr_page_fault <= 1'b0;
                id_instr_addr_misaligned <= 1'b0;
                id_instr_no_exec_access <= 1'b0;
            end
        end 
    end
endmodule

module id_ex(
    input wire clock,
    input wire reset,

    input wire stall,
    input wire bubble,
    output reg error,

    // Control signals.
    input wire [31:0] id_ip,
    output reg [31:0] ex_ip,

    input wire        id_jump_pred,
    output reg        ex_jump_pred,

    input wire [31:0] id_instr,
    output reg [31:0] ex_instr,

    // Prepare for what ALU need.
    input wire [31:0] id_op1,
    output reg [31:0] ex_op1,

    input wire [31:0] id_op2, 
    output reg [31:0] ex_op2,

    // Metadata for Device access stage -- maddr
    // is calculated in ALU stage.

    // For Device access unit.
    input wire        id_mre,
    output reg        ex_mre,

    input wire        id_mwe,
    output reg        ex_mwe,

    /*input wire [ 3:0] id_mbe,
    output reg [ 3:0] ex_mbe, */ // No, don't do this.

    input wire [31:0] id_mdata,
    output reg [31:0] ex_mdata,

    // For CSR
    input wire        id_csracc,
    output reg        ex_csracc,

    input wire [31:0] id_csrdata,
    output reg [31:0] ex_csrdata,

    input wire        id_instr_page_fault,
    output reg        ex_instr_page_fault,

    input wire        id_instr_addr_misaligned,
    output reg        ex_instr_addr_misaligned,

    input wire        id_instr_no_exec_access,
    output reg        ex_instr_no_exec_access,

    // For Cached Unit.
    input wire        id_clear_tlb,
    output reg        ex_clear_tlb,

    input wire        id_clear_icache,
    output reg        ex_clear_icache,

    // Metadata for Write back stage -- wrdata 
    // is calcuated in ALU stage, not our duty.
    input wire        id_we,
    output reg        ex_we,

    input wire [ 4:0] id_wraddr,
    output reg [ 4:0] ex_wraddr,

    input wire [31:0] bubble_ip
);
    parameter NOP = 32'b0000_0000_0000_0000_0000_0000_0001_0011;
    parameter INSTR_BASE_ADDR = 32'h8000_0000;

    always_ff @(posedge clock or posedge reset) begin
        if(reset) begin
            // 0. Control
            ex_ip       <= INSTR_BASE_ADDR;
            ex_jump_pred <= 1'b0;
            ex_instr    <= NOP;

            // 1. ALU
            ex_op1      <= 32'b0;
            ex_op2      <= 32'b0;

            // 2. Device
            ex_mre      <=  1'b0;
            ex_mwe      <=  1'b0;
            // ex_mbe      <=  4'b0;
            ex_mdata    <= 32'b0;

            // CSR.
            ex_csracc   <=  1'b0;
            ex_csrdata  <= 32'b0;
            
            ex_instr_page_fault <= 1'b0;
            ex_instr_addr_misaligned <= 1'b0;
            ex_instr_no_exec_access <= 1'b0;

            ex_clear_tlb<=  1'b0;
            ex_clear_icache <= 1'b0;
            // 3. Write back
            ex_we       <=  1'b1; // NOP is addi x0,x0,0
            ex_wraddr   <=  5'b0;
            error <= 1'b0;
        end else begin
            // error <= stall && bubble;
            if(bubble) begin
                // NOP = addi x0, x0, 0
                // 0. Control
                ex_ip       <= bubble_ip;
                ex_jump_pred <= 1'b0;
                ex_instr    <= NOP;

                // 1. ALU
                ex_op1      <= 32'b0;
                ex_op2      <= 32'b0;

                // 2. Device
                ex_mre      <=  1'b0;
                ex_mwe      <=  1'b0;
                // ex_mbe      <=  4'b0;
                ex_mdata    <= 32'b0;

                // CSR
                ex_csracc   <=  1'b0;
                ex_csrdata  <= 32'b0;

                ex_instr_page_fault <= 1'b0;
                ex_instr_addr_misaligned <= 1'b0;
                ex_instr_no_exec_access <= 1'b0;
                
                ex_clear_tlb<=  1'b0;
                ex_clear_icache <= 1'b0;

                // 3. Write back
                ex_we       <=  1'b1;
                ex_wraddr   <=  5'b0;

            end else if(!stall) begin
                // 0. Control
                ex_ip       <= id_ip;
                ex_jump_pred <= id_jump_pred;
                ex_instr    <= id_instr;
                
                // 1. ALU
                ex_op1      <= id_op1;
                ex_op2      <= id_op2;

                // 2. Device
                ex_mre      <= id_mre;
                ex_mwe      <= id_mwe;
                // ex_mbe      <= id_mbe;
                ex_mdata    <= id_mdata;

                // CSR
                ex_csracc   <= id_csracc;
                ex_csrdata  <= id_csrdata;

                ex_instr_page_fault <= id_instr_page_fault;
                ex_instr_addr_misaligned <= id_instr_addr_misaligned;
                ex_instr_no_exec_access <= id_instr_no_exec_access;

                ex_clear_tlb<=  id_clear_tlb;
                ex_clear_icache <= id_clear_icache;

                // 3. Write back
                ex_we       <= id_we;
                ex_wraddr   <= id_wraddr;
            end
        end 
    end
endmodule

module ex_mem(
    input wire clock,
    input wire reset,

    input wire stall,
    input wire bubble,
    output reg error,
    
    input wire [31:0]  ex_ip,
    output reg [31:0] mem_ip,

    // Prepare for what DAU need.
    input wire [31:0]  ex_instr,
    output reg [31:0] mem_instr,

    input wire         ex_mre,
    output reg        mem_mre,

    input wire         ex_mwe,
    output reg        mem_mwe,

    input wire [ 3:0]  ex_mbe,
    output reg [ 3:0] mem_mbe,

    input wire [31:0]  ex_maddr,
    output reg [31:0] mem_maddr,
    
    input wire [31:0]  ex_mdata,
    output reg [31:0] mem_mdata,
    
    // Prepare for trap handler.
    input wire         ex_csracc,
    output reg        mem_csracc,

    input wire [31:0]  ex_csrdt,
    output reg [31:0] mem_csrdt,

    input wire         ex_instr_page_fault,
    output reg        mem_instr_page_fault,

    input wire         ex_instr_addr_misaligned,
    output reg        mem_instr_addr_misaligned,

    input wire         ex_instr_no_exec_access,
    output reg        mem_instr_no_exec_access,
    
    // Prepare for d-cache,
    input wire         ex_clear_tlb,
    output reg        mem_clear_tlb,

    input wire         ex_clear_icache,
    output reg        mem_clear_icache,

    // Metadata for next stage.
    input wire         ex_we,
    output reg        mem_we,

    input wire [ 4:0]  ex_wraddr,
    output reg [ 4:0] mem_wraddr,

    input wire [31:0]  ex_wdata,
    output reg [31:0] mem_wdata,

    input wire [31:0] bubble_ip
);
    parameter NOP = 32'b0000_0000_0000_0000_0000_0000_0001_0011;
    parameter INSTR_BASE_ADDR = 32'h8000_0000;

    always_ff @(posedge clock or posedge reset) begin
        if(reset) begin
            mem_ip    <= INSTR_BASE_ADDR;
            // NOP = addi x0, x0, 0
            // 1. Device
            mem_mre    <=  1'b0;
            mem_mwe    <=  1'b0;
            mem_mbe    <=  4'b0;
            mem_maddr  <= 32'b0;
            mem_mdata  <= 32'b0;

            mem_csracc <= 1'b0;
            mem_csrdt  <= 32'b0;

            mem_instr_page_fault <= 1'b0;
            mem_instr_addr_misaligned <= 1'b0;
            mem_instr_no_exec_access <= 1'b0; 

            mem_clear_tlb <= 1'b0;
            mem_clear_icache <= 1'b0;
            // 2. Write back
            mem_we     <=  1'b1;
            mem_wraddr <= 32'b0;
            mem_wdata  <= 32'b0;
            
            // Initial state configurations.
            error      <=  1'b0;

            // Debug only.
            mem_instr  <=   NOP;
        end else begin
            error <= stall && bubble;
            if(bubble) begin
                mem_ip     <= bubble_ip;
                // 1. Device
                mem_mre    <=  1'b0;
                mem_mwe    <=  1'b0;
                mem_mbe    <=  4'b0;
                mem_maddr  <= 32'b0;
                mem_mdata  <= 32'b0;

                mem_csracc <= 1'b0;
                mem_csrdt  <= 32'b0;

                mem_instr_page_fault <= 1'b0;
                mem_instr_addr_misaligned <= 1'b0;
                mem_instr_no_exec_access <= 1'b0; 

                mem_clear_tlb <= 1'b0;
                mem_clear_icache <= 1'b0;

                // 2. Write back
                mem_we     <=  1'b1;
                mem_wraddr <= 32'b0;
                mem_wdata  <= 32'b0;

                // Debug only.
                mem_instr  <=   NOP;
            end else if (!stall) begin
                mem_instr  <= ex_instr;
                mem_ip     <= ex_ip;
                // 1. Device
                mem_mre    <= ex_mre;
                mem_mwe    <= ex_mwe;
                mem_mbe    <= ex_mbe;
                mem_maddr  <= ex_maddr;
                mem_mdata  <= ex_mdata;

                mem_csracc <= ex_csracc;
                mem_csrdt  <= ex_csrdt;

                mem_instr_page_fault <= ex_instr_page_fault;
                mem_instr_addr_misaligned <= ex_instr_addr_misaligned;
                mem_instr_no_exec_access <= ex_instr_no_exec_access; 

                mem_clear_tlb <= ex_clear_tlb;
                mem_clear_icache <= ex_clear_icache;

                // 2. Write back
                mem_we     <= ex_we;
                mem_wraddr <= ex_wraddr;
                mem_wdata  <= ex_wdata;

            end
        end
    end
endmodule

module mem_wb(
    input wire clock,
    input wire reset,

    input wire stall,
    input wire bubble,
    output reg error,

    input wire       mem_we,
    output reg        wb_we,

    input wire [4:0] mem_wraddr,
    output reg [4:0]  wb_wraddr,

    input wire [31:0] mem_wdata,
    output reg [31:0]  wb_wdata,

    // For your convenience to debug
    input wire [31:0] mem_instr,
    output reg [31:0]  wb_instr,

    input wire [31:0] mem_ip,
    output reg [31:0]  wb_ip

);
    parameter NOP = 32'b0000_0000_0000_0000_0000_0000_0001_0011;
    always_ff @(posedge clock or posedge reset) begin
        if(reset) begin
            // Pass to reg file
            wb_we       <=  1'b1;
            wb_wraddr   <=  5'b0;
            wb_wdata    <= 32'b0;

            // Initial state configurations.
            error       <=  1'b0;

            // Debug only.
            wb_instr    <=   NOP;
            wb_ip       <= 32'h8000_0000;
        end else begin
            error <= stall && bubble;
            if(bubble) begin
                // NOP = addi x0, x0, 0
                wb_we     <=  1'b1;
                wb_wraddr <=  5'b0;
                wb_wdata  <= 32'b0;
                
                wb_instr  <=   NOP;

            end else if(!stall) begin
                wb_we     <= mem_we;
                wb_wraddr <= mem_wraddr;
                wb_wdata  <= mem_wdata;

                wb_instr  <= mem_instr;
            end
            wb_ip <= mem_ip;
        end 
    end
endmodule
