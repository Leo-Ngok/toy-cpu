`define NOP 32'b0000_0000_0000_0000_0000_0000_0001_0011
`define START_ADDR 32'h8000_0000
module pre_if (
    input wire clock,
    input wire reset,

    input  wire stall,
    input  wire bubble,
    output reg  error,

    input  wire [31:0] next_instr_ptr,
    output reg  [31:0] instr_ptr
);
  always_ff @(posedge clock  /* or posedge reset */) begin
    if (reset) begin
      instr_ptr <= `START_ADDR;
      error <= 1'b0;
    end else begin
      error <= stall && bubble;
      if (!stall) begin
        instr_ptr <= next_instr_ptr;
      end
    end
  end
endmodule

module if1_if2 (
    input wire clock,
    input wire reset,

    input wire stall,
    input wire bubble,

    input  wire [31:0] if1_ip,
    output reg  [31:0] if2_ip,

    input  wire [31:0] if1_ppc,
    output reg  [31:0] if2_ppc,

    // these signals are generated by cu_orchestra module.
    input wire [31:0] bubble_ip,

    input  wire if1_page_fault,
    output reg  if2_instr_page_fault,

    input  wire if1_addr_misaligned,
    output reg  if2_instr_addr_misaligned,

    input  wire if1_no_exec_access,
    output reg  if2_instr_no_exec_access,

    input  wire [31:0] if1_alt_next_ip,
    output reg  [31:0] if2_alt_next_ip,

    output reg is_bubble
);
  always_ff @(posedge clock  /* or posedge reset */) begin
    if (reset) begin
      if2_ip    <= `START_ADDR;
      if2_ppc <= `START_ADDR;
      if2_instr_page_fault <= 1'b0;
      if2_instr_addr_misaligned <= 1'b0;
      if2_instr_no_exec_access <= 1'b0;
      if2_alt_next_ip <= `START_ADDR + 32'd4;
      is_bubble <= 1;
    end else begin
      if (bubble) begin
        if2_ip                    <= bubble_ip;
        if2_ppc                   <= bubble_ip;
        if2_instr_page_fault      <= 1'b0;
        if2_instr_addr_misaligned <= 1'b0;
        if2_instr_no_exec_access  <= 1'b0;
        if2_alt_next_ip           <= bubble_ip + 4;
      end else if (!stall) begin
        if2_ip                    <= if1_ip;
        if2_ppc                   <= if1_ppc;
        if2_instr_page_fault      <= if1_page_fault;
        if2_instr_addr_misaligned <= if1_addr_misaligned;
        if2_instr_no_exec_access  <= if1_no_exec_access;
        if2_alt_next_ip           <= if1_alt_next_ip;
      end
      is_bubble <= bubble;
    end
  end
endmodule

module if_id (
    input wire clock,
    input wire reset,

    input  wire stall,
    input  wire bubble,
    output reg  error,

    input  wire [31:0] if_ip,
    output reg  [31:0] id_ip,

    input  wire [31:0] if_instr,
    output reg  [31:0] id_instr,

    input  wire [31:0] if_instr_delayed,
    output reg  [31:0] id_instr_delayed,

    // these signals are generated by cu_orchestra module.
    input wire [31:0] bubble_ip,

    input  wire if_page_fault,
    output reg  id_instr_page_fault,

    input  wire if_addr_misaligned,
    output reg  id_instr_addr_misaligned,

    input  wire if_no_exec_access,
    output reg  id_instr_no_exec_access,

    input  wire [31:0] if_alt_next_ip,
    output reg  [31:0] id_alt_next_ip,

    input wire if2_is_bubble
);
  reg stall_relay;
  reg bubble_relay;
  reg [31:0] instr_relay;
  reg id_is_bubble;
  always_ff @(posedge clock  /* or posedge reset */) begin
    if (reset) begin
      id_ip                    <= `START_ADDR;
      id_instr                 <= `NOP;
      error                    <= 1'b0;
      id_instr_page_fault      <= 1'b0;
      id_instr_addr_misaligned <= 1'b0;
      id_instr_no_exec_access  <= 1'b0;
      id_alt_next_ip           <= `START_ADDR + 32'd4;
      stall_relay              <= 0;
      bubble_relay             <= 1;
      instr_relay              <= `NOP;
      id_is_bubble             <= 1;
    end else begin
      // error <= stall && bubble;      
      stall_relay  <= stall;
      bubble_relay <= bubble;
      if (stall && !stall_relay) instr_relay <= if_instr_delayed;
      if (bubble) begin
        id_ip                    <= bubble_ip;
        id_instr                 <= `NOP;
        id_instr_page_fault      <= 1'b0;
        id_instr_addr_misaligned <= 1'b0;
        id_instr_no_exec_access  <= 1'b0;
        id_alt_next_ip           <= bubble_ip + 4;
        id_is_bubble             <= 1;
      end else if (!stall) begin
        id_ip                    <= if_ip;
        id_instr                 <= if2_is_bubble ? `NOP : if_instr;
        id_instr_page_fault      <= if_page_fault;
        id_instr_addr_misaligned <= if_addr_misaligned;
        id_instr_no_exec_access  <= if_no_exec_access;
        id_alt_next_ip           <= if_alt_next_ip;
        id_is_bubble             <= if2_is_bubble;
      end
    end
  end

  always_comb begin
    if (bubble_relay || id_is_bubble) id_instr_delayed = `NOP;
    else if (stall_relay) id_instr_delayed = instr_relay;
    else id_instr_delayed = if_instr_delayed;
  end
endmodule

module id_ex (
    input wire clock,
    input wire reset,

    input  wire stall,
    input  wire bubble,
    output reg  error,

    // Control signals.
    input  wire [31:0] id_ip,
    output reg  [31:0] ex_ip,

    input  wire [31:0] id_instr,
    output reg  [31:0] ex_instr,

    // Prepare for what ALU need.
    input  wire [31:0] id_op1,
    output reg  [31:0] ex_op1,

    input  wire [31:0] id_op2,
    output reg  [31:0] ex_op2,

    input  wire [31:0] id_imm,
    output reg  [31:0] ex_imm,
    // Metadata for Device access stage -- maddr
    // is calculated in ALU stage.

    // For Device access unit.
    input  wire id_mre,
    output reg  ex_mre,

    input  wire id_mwe,
    output reg  ex_mwe,

    /*input wire [ 3:0] id_mbe,
    output reg [ 3:0] ex_mbe, */  // No, don't do this.

    input  wire [31:0] id_mdata,
    output reg  [31:0] ex_mdata,

    // For CSR
    input  wire id_csracc,
    output reg  ex_csracc,

    input  wire [31:0] id_csrdata,
    output reg  [31:0] ex_csrdata,

    input  wire id_instr_page_fault,
    output reg  ex_instr_page_fault,

    input  wire id_instr_addr_misaligned,
    output reg  ex_instr_addr_misaligned,

    input  wire id_instr_no_exec_access,
    output reg  ex_instr_no_exec_access,

    // For Cached Unit.
    input  wire id_clear_tlb,
    output reg  ex_clear_tlb,

    input  wire id_clear_icache,
    output reg  ex_clear_icache,

    // Metadata for Write back stage -- wrdata 
    // is calcuated in ALU stage, not our duty.
    input  wire id_we,
    output reg  ex_we,

    input  wire [4:0] id_wraddr,
    output reg  [4:0] ex_wraddr,

    input wire [31:0] bubble_ip,

    input  wire [31:0] id_alt_next_ip,
    output reg  [31:0] ex_alt_next_ip
);

  always_ff @(posedge clock  /* or posedge reset */) begin
    if (reset) begin
      // 0. Control
      ex_ip                    <= `START_ADDR;
      ex_instr                 <= `NOP;

      // 1. ALU
      ex_op1                   <= 32'b0;
      ex_op2                   <= 32'b0;
      ex_imm                   <= 32'b0;

      // 2. Device
      ex_mre                   <= 1'b0;
      ex_mwe                   <= 1'b0;
      // ex_mbe      <=  4'b0;
      ex_mdata                 <= 32'b0;

      // CSR.
      ex_csracc                <= 1'b0;
      ex_csrdata               <= 32'b0;

      ex_instr_page_fault      <= 1'b0;
      ex_instr_addr_misaligned <= 1'b0;
      ex_instr_no_exec_access  <= 1'b0;

      ex_clear_tlb             <= 1'b0;
      ex_clear_icache          <= 1'b0;
      // 3. Write back
      ex_we                    <= 1'b1;  // NOP is addi x0,x0,0
      ex_wraddr                <= 5'b0;
      error                    <= 1'b0;

      ex_alt_next_ip           <= `START_ADDR + 32'd4;
    end else begin
      // error <= stall && bubble;
      if (bubble) begin
        // NOP = addi x0, x0, 0
        // 0. Control
        ex_ip                    <= bubble_ip;
        ex_instr                 <= `NOP;

        // 1. ALU
        ex_op1                   <= 32'b0;
        ex_op2                   <= 32'b0;
        ex_imm                   <= 32'b0;

        // 2. Device
        ex_mre                   <= 1'b0;
        ex_mwe                   <= 1'b0;
        // ex_mbe      <=  4'b0;
        ex_mdata                 <= 32'b0;

        // CSR
        ex_csracc                <= 1'b0;
        ex_csrdata               <= 32'b0;

        ex_instr_page_fault      <= 1'b0;
        ex_instr_addr_misaligned <= 1'b0;
        ex_instr_no_exec_access  <= 1'b0;

        ex_clear_tlb             <= 1'b0;
        ex_clear_icache          <= 1'b0;

        // 3. Write back
        ex_we                    <= 1'b1;
        ex_wraddr                <= 5'b0;
        ex_alt_next_ip           <= bubble_ip + 4;
      end else if (!stall) begin
        // 0. Control
        ex_ip                    <= id_ip;
        ex_instr                 <= id_instr;

        // 1. ALU
        ex_op1                   <= id_op1;
        ex_op2                   <= id_op2;
        ex_imm                   <= id_imm;

        // 2. Device
        ex_mre                   <= id_mre;
        ex_mwe                   <= id_mwe;
        // ex_mbe      <= id_mbe;
        ex_mdata                 <= id_mdata;

        // CSR
        ex_csracc                <= id_csracc;
        ex_csrdata               <= id_csrdata;

        ex_instr_page_fault      <= id_instr_page_fault;
        ex_instr_addr_misaligned <= id_instr_addr_misaligned;
        ex_instr_no_exec_access  <= id_instr_no_exec_access;

        ex_clear_tlb             <= id_clear_tlb;
        ex_clear_icache          <= id_clear_icache;

        // 3. Write back
        ex_we                    <= id_we;
        ex_wraddr                <= id_wraddr;

        ex_alt_next_ip           <= id_alt_next_ip;
      end
    end
  end
endmodule

module ex_mem (
    input wire clock,
    input wire reset,

    input  wire stall,
    input  wire bubble,
    output reg  error,

    input  wire [31:0] ex_ip,
    output reg  [31:0] mem_ip,

    // Prepare for what DAU need.
    input  wire [31:0] ex_instr,
    output reg  [31:0] mem_instr,

    input  wire ex_mre,
    output reg  mem_mre,

    input  wire ex_mwe,
    output reg  mem_mwe,

    input  wire [3:0] ex_mbe,
    output reg  [3:0] mem_mbe,

    input  wire [31:0] ex_maddr,
    output reg  [31:0] mem_maddr,

    input  wire [31:0] ex_mdata,
    output reg  [31:0] mem_mdata,

    input  wire [31:0] ex_mpa,
    output reg  [31:0] mem_mpa,
    // Prepare for trap handler.
    input  wire        ex_csracc,
    output reg         mem_csracc,

    input  wire [31:0] ex_csrdt,
    output reg  [31:0] mem_csrdt,

    input  wire ex_instr_page_fault,
    output reg  mem_instr_page_fault,

    input  wire ex_instr_addr_misaligned,
    output reg  mem_instr_addr_misaligned,

    input  wire ex_instr_no_exec_access,
    output reg  mem_instr_no_exec_access,

    // Prepare for d-cache,
    input  wire ex_clear_tlb,
    output reg  mem_clear_tlb,

    input  wire ex_clear_icache,
    output reg  mem_clear_icache,

    input  wire [31:0] ex_dmmu_pa,
    output reg  [31:0] mem_dmmu_pa,

    input  wire ex_dmmu_page_fault,
    output reg  mem_dmmu_page_fault,

    input  wire ex_dmmu_read_violation,
    output reg  mem_dmmu_read_violation,

    input  wire ex_dmmu_write_violation,
    output reg  mem_dmmu_write_violation,

    input  wire ex_dmmu_addr_misaligned,
    output reg  mem_dmmu_addr_misaligned,

    // Metadata for next stage.
    input  wire ex_we,
    output reg  mem_we,

    input  wire [4:0] ex_wraddr,
    output reg  [4:0] mem_wraddr,

    input  wire [31:0] ex_wdata,
    output reg  [31:0] mem_wdata,

    input wire [31:0] bubble_ip
);

  always_ff @(posedge clock  /* or posedge reset */) begin
    if (reset) begin
      mem_ip                    <= `START_ADDR;
      // NOP = addi x0, x0, 0
      // 1. Device
      mem_mre                   <= 1'b0;
      mem_mwe                   <= 1'b0;
      mem_mbe                   <= 4'b0;
      mem_maddr                 <= 32'b0;
      mem_mdata                 <= 32'b0;
      mem_mpa                   <= 32'b0;

      mem_csracc                <= 1'b0;
      mem_csrdt                 <= 32'b0;

      mem_instr_page_fault      <= 1'b0;
      mem_instr_addr_misaligned <= 1'b0;
      mem_instr_no_exec_access  <= 1'b0;

      mem_clear_tlb             <= 1'b0;
      mem_clear_icache          <= 1'b0;

      mem_dmmu_pa               <= 32'b0;
      mem_dmmu_page_fault       <= 1'b0;
      mem_dmmu_read_violation   <= 1'b0;
      mem_dmmu_write_violation  <= 1'b0;
      mem_dmmu_addr_misaligned  <= 1'b0;
      // 2. Write back
      mem_we                    <= 1'b1;
      mem_wraddr                <= 5'b0;
      mem_wdata                 <= 32'b0;

      // Initial state configurations.
      error                     <= 1'b0;

      // Debug only.
      mem_instr                 <= `NOP;
    end else begin
      error <= stall && bubble;
      if (bubble) begin
        mem_ip                    <= bubble_ip;
        // 1. Device
        mem_mre                   <= 1'b0;
        mem_mwe                   <= 1'b0;
        mem_mbe                   <= 4'b0;
        mem_maddr                 <= 32'b0;
        mem_mdata                 <= 32'b0;
        mem_mpa                   <= 32'b0;

        mem_csracc                <= 1'b0;
        mem_csrdt                 <= 32'b0;

        mem_instr_page_fault      <= 1'b0;
        mem_instr_addr_misaligned <= 1'b0;
        mem_instr_no_exec_access  <= 1'b0;

        mem_clear_tlb             <= 1'b0;
        mem_clear_icache          <= 1'b0;

        mem_dmmu_pa               <= 32'b0;
        mem_dmmu_page_fault       <= 1'b0;
        mem_dmmu_read_violation   <= 1'b0;
        mem_dmmu_write_violation  <= 1'b0;
        mem_dmmu_addr_misaligned  <= 1'b0;

        // 2. Write back
        mem_we                    <= 1'b1;
        mem_wraddr                <= 5'b0;
        mem_wdata                 <= 32'b0;

        // Debug only.
        mem_instr                 <= `NOP;
      end else if (!stall) begin
        mem_instr                 <= ex_instr;
        mem_ip                    <= ex_ip;
        // 1. Device
        mem_mre                   <= ex_mre;
        mem_mwe                   <= ex_mwe;
        mem_mbe                   <= ex_mbe;
        mem_maddr                 <= ex_maddr;
        mem_mdata                 <= ex_mdata;
        mem_mpa                   <= ex_mpa;

        mem_csracc                <= ex_csracc;
        mem_csrdt                 <= ex_csrdt;

        mem_instr_page_fault      <= ex_instr_page_fault;
        mem_instr_addr_misaligned <= ex_instr_addr_misaligned;
        mem_instr_no_exec_access  <= ex_instr_no_exec_access;

        mem_clear_tlb             <= ex_clear_tlb;
        mem_clear_icache          <= ex_clear_icache;

        mem_dmmu_pa               <= ex_dmmu_pa;
        mem_dmmu_page_fault       <= ex_dmmu_page_fault;
        mem_dmmu_read_violation   <= ex_dmmu_read_violation;
        mem_dmmu_write_violation  <= ex_dmmu_write_violation;
        mem_dmmu_addr_misaligned  <= ex_dmmu_addr_misaligned;

        // 2. Write back
        mem_we                    <= ex_we;
        mem_wraddr                <= ex_wraddr;
        mem_wdata                 <= ex_wdata;

      end
    end
  end
endmodule

module mem_wb (
    input wire clock,
    input wire reset,

    input  wire stall,
    input  wire bubble,
    output reg  error,

    // Basic information
    input  wire [31:0] bubble_ip,
    input  wire [31:0] mem_ip,
    output reg  [31:0] wb_ip,

    input  wire [31:0] mem_instr,
    output reg  [31:0] wb_instr,

    input  wire mem_we,
    output reg  wb_we,

    input  wire mem_mre,
    output reg  wb_mre,

    input  wire [31:0] mem_maddr,
    output reg  [31:0] wb_maddr,

    input  wire mem_csracc,
    output reg  wb_csracc,

    input  wire [4:0] mem_wraddr,
    output reg  [4:0] wb_wraddr,

    input  wire [31:0] mem_wmdata,
    output reg  [31:0] wb_wmdata,

    input  wire [31:0] mem_wmdata_delayed,
    output reg  [31:0] wb_wmdata_delayed,

    input  wire [31:0] mem_wcsrdata,
    output reg  [31:0] wb_wcsrdata,

    input  wire [31:0] mem_waludata,
    output reg  [31:0] wb_waludata
);

  reg stall_relay;
  reg bubble_relay;
  reg [31:0] mem_data_relay;
  always_ff @(posedge clock  /* or posedge reset */) begin
    if (reset) begin
      wb_ip          <= `START_ADDR;
      wb_instr       <= `NOP;

      wb_we          <= 1'b1;
      wb_mre         <= 0;
      wb_csracc      <= 0;

      wb_maddr       <= 32'b0;

      wb_wraddr      <= 5'b0;
      wb_wmdata      <= 32'b0;
      wb_wcsrdata    <= 32'b0;
      wb_waludata    <= 32'b0;

      mem_data_relay <= 32'b0;
    end else begin
      error <= stall && bubble;
      stall_relay <= stall;
      bubble_relay <= bubble;
      if (stall && !stall_relay) mem_data_relay <= mem_wmdata_delayed;
      if (bubble) begin
        wb_ip       <= bubble_ip;
        wb_instr    <= `NOP;

        wb_we       <= 1'b1;
        wb_mre      <= 0;
        wb_csracc   <= 0;

        wb_maddr    <= 32'b0;

        wb_wraddr   <= 5'b0;
        wb_wmdata   <= 32'b0;
        wb_wcsrdata <= 32'b0;
        wb_waludata <= 32'b0;

      end else if (!stall) begin
        wb_ip       <= mem_ip;
        wb_instr    <= mem_instr;

        wb_we       <= mem_we;
        wb_mre      <= mem_mre;
        wb_csracc   <= mem_csracc;
        wb_wraddr   <= mem_wraddr;

        wb_maddr    <= mem_maddr;

        wb_wmdata   <= mem_wmdata;
        wb_wcsrdata <= mem_wcsrdata;
        wb_waludata <= mem_waludata;
      end

    end
  end

  always_comb begin
    if (bubble_relay) wb_wmdata_delayed = 32'b0;
    else if (stall_relay) wb_wmdata_delayed = mem_data_relay;
    else wb_wmdata_delayed = mem_wmdata_delayed;
  end
endmodule
